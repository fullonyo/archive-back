const axios = require('axios')
const { PrismaClient } = require('@prisma/client')
const prisma = new PrismaClient()

class VRChatService {
  constructor() {
    this.baseURL = 'https://api.vrchat.cloud/api/1'
    this.userAgent = 'VRCHIEVE/2.1.3 (Archive Nyo Integration)'
    this.lastRequestTime = 0
    this.minDelayBetweenRequests = 15000 // 15 segundos entre requests
    this.rateLimitRetryDelay = 30000 // 30 segundos para rate limit
    
    this.axiosInstance = axios.create({
      baseURL: this.baseURL,
      headers: {
        'User-Agent': this.userAgent,
        'Content-Type': 'application/json'
      },
      timeout: 10000
    })

    // Interceptor para logging
    this.axiosInstance.interceptors.request.use(
      (config) => {
        console.log(`üîó VRChat API Request: ${config.method?.toUpperCase()} ${config.url}`)
        console.log(`üîë Headers:`, Object.keys(config.headers || {}))
        return config
      },
      (error) => {
        console.error('‚ùå VRChat API Request Error:', error)
        return Promise.reject(error)
      }
    )

    this.axiosInstance.interceptors.response.use(
      (response) => {
        console.log(`‚úÖ VRChat API Response: ${response.status} ${response.config.url}`)
        return response
      },
      (error) => {
        console.error('‚ùå VRChat API Response Error:', {
          status: error.response?.status,
          statusText: error.response?.statusText,
          url: error.config?.url,
          message: error.message
        })
        return Promise.reject(error)
      }
    )
  }

  async waitForRateLimit() {
    const now = Date.now()
    const timeSinceLastRequest = now - this.lastRequestTime
    
    if (timeSinceLastRequest < this.minDelayBetweenRequests) {
      const waitTime = this.minDelayBetweenRequests - timeSinceLastRequest
      console.log(`‚è≥ Aguardando ${Math.round(waitTime/1000)}s para evitar rate limiting...`)
      await new Promise(resolve => setTimeout(resolve, waitTime))
    }
    
    this.lastRequestTime = Date.now()
  }

  /**
   * Autentica usu√°rio com VRChat (com retry para rate limiting)
   * @param {string} username - Username do VRChat
   * @param {string} password - Password do VRChat
   * @param {string} twoFactorAuth - C√≥digo 2FA (opcional)
   * @param {number} retryCount - Contador de tentativas
   * @param {boolean} detected2FA - Flag para indicar se 2FA foi detectado antes
   * @returns {Promise<Object>} Dados de autentica√ß√£o
   */
  async authenticateUser(username, password, twoFactorAuth = null, retryCount = 0, detected2FA = false) {
    const maxRetries = 2
    
    try {
      // Aguarda para evitar rate limiting
      await this.waitForRateLimit()
      
      // Log do tipo de credencial (email vs username)
      const isEmail = username.includes('@')
      console.log(`üîê VRChat Auth: Using ${isEmail ? 'EMAIL' : 'USERNAME'} - ${username.substring(0, 3)}***`)
      
      // Codifica credenciais em base64
      const credentials = Buffer.from(`${username}:${password}`).toString('base64')
      
      // PASSO 1: Login inicial para obter cookie e detectar 2FA
      const initialResponse = await this.axiosInstance.get('/auth/user', {
        headers: {
          'Authorization': `Basic ${credentials}`
        }
      })
      
      console.log('üîç VRChat Initial Response:', JSON.stringify(initialResponse.data, null, 2))
      
      // Extrai cookie da resposta
      const setCookieHeader = initialResponse.headers['set-cookie']
      let authCookie = null
      
      if (setCookieHeader) {
        const authCookieMatch = setCookieHeader.find(cookie => cookie.startsWith('auth='))
        if (authCookieMatch) {
          authCookie = authCookieMatch.split(';')[0] // Pega s√≥ a parte "auth=valor"
          console.log('üç™ Cookie extra√≠do para 2FA')
        }
      }
      
      // Verifica se precisa de 2FA
      if (initialResponse.data.requiresTwoFactorAuth) {
        console.log('üîê VRChat requires 2FA authentication:', initialResponse.data.requiresTwoFactorAuth)
        
        // Se n√£o temos c√≥digo 2FA, retorna para solicitar
        if (!twoFactorAuth) {
          return {
            success: false,
            requires2FA: true,
            twoFAType: initialResponse.data.requiresTwoFactorAuth,
            error: 'C√≥digo de verifica√ß√£o necess√°rio',
            authCookie: authCookie // Salva cookie para pr√≥xima tentativa
          }
        }
        
        // Se temos c√≥digo 2FA, verifica
        if (twoFactorAuth && authCookie) {
          console.log(`üîê Verificando c√≥digo 2FA: ${twoFactorAuth}`)
          
          try {
            // PASSO 2: Verifica√ß√£o 2FA com m√©todo oficial
            const twoFAResponse = await this.axiosInstance.post('/auth/twofactorauth/emailotp/verify', {
              code: twoFactorAuth
            }, {
              headers: {
                'Cookie': authCookie
              }
            })
            
            console.log('‚úÖ Resposta 2FA:', JSON.stringify(twoFAResponse.data, null, 2))
            
            if (twoFAResponse.data.verified === true) {
              // Aguarda um pouco ap√≥s verifica√ß√£o
              await new Promise(resolve => setTimeout(resolve, 2000))
              
              // PASSO 3: Busca dados completos do usu√°rio
              const finalResponse = await this.axiosInstance.get('/auth/user', {
                headers: {
                  'Cookie': authCookie
                }
              })
              
              console.log('‚úÖ Dados finais do usu√°rio obtidos!')
              
              if (finalResponse.data.id) {
                return {
                  success: true,
                  user: finalResponse.data,
                  message: 'Autentica√ß√£o VRChat completada com sucesso!'
                }
              } else {
                return {
                  success: false,
                  requires2FA: true,
                  twoFAType: initialResponse.data.requiresTwoFactorAuth,
                  error: 'Falha ao obter dados do usu√°rio ap√≥s 2FA'
                }
              }
            } else {
              return {
                success: false,
                requires2FA: true,
                twoFAType: initialResponse.data.requiresTwoFactorAuth,
                error: 'C√≥digo de verifica√ß√£o inv√°lido ou expirado'
              }
            }
            
          } catch (twoFAError) {
            console.log('‚ùå Erro na verifica√ß√£o 2FA:', twoFAError.response?.data || twoFAError.message)
            return {
              success: false,
              requires2FA: true,
              twoFAType: initialResponse.data.requiresTwoFactorAuth,
              error: 'C√≥digo de verifica√ß√£o inv√°lido ou expirado'
            }
          }
        } else {
          return {
            success: false,
            requires2FA: true,
            twoFAType: initialResponse.data.requiresTwoFactorAuth,
            error: 'Cookie n√£o dispon√≠vel para verifica√ß√£o 2FA'
          }
        }
      }
      
      // Se chegou aqui, login bem-sucedido sem 2FA
      if (initialResponse.data.id) {
        return {
          success: true,
          user: initialResponse.data,
          message: 'Autentica√ß√£o VRChat completada com sucesso!'
        }
      } else {
        return {
          success: false,
          error: 'Falha na autentica√ß√£o VRChat'
        }
      }
      
    } catch (error) {
      console.error('‚ùå VRChat authentication failed:', error.message)
      
      // Rate limiting - com delays maiores
      if (error.response?.status === 429) {
        if (retryCount < maxRetries) {
          const waitTime = this.rateLimitRetryDelay + (retryCount * 10000) // 30s, 40s, 50s
          console.log(`‚è≥ Rate limited. Aguardando ${Math.round(waitTime/1000)}s antes de retry (tentativa ${retryCount + 1}/${maxRetries + 1})`)
          
          await new Promise(resolve => setTimeout(resolve, waitTime))
          return this.authenticateUser(username, password, twoFactorAuth, retryCount + 1, detected2FA)
        } else {
          // M√°ximo de retries atingido
          return {
            success: false,
            error: 'Muitas tentativas falharam devido a rate limiting. Aguarde alguns minutos antes de tentar novamente.',
            rateLimited: true
          }
        }
      }
      
      if (error.response?.status === 401) {
        return {
          success: false,
          error: 'Credenciais inv√°lidas. Verifique seu email/username e senha.'
        }
      }

      return {
        success: false,
        error: `Erro na autentica√ß√£o VRChat: ${error.message}`
      }
    }
  }
        
        // SEGUNDO: Verifica se h√° dados de usu√°rio autenticado (sucesso completo)
        if (response.data.id || response.data.user?.id || response.data.currentUser?.id) {
          const userData = response.data.user || response.data.currentUser || response.data
          console.log(`‚úÖ VRChat authentication successful for user: ${userData.displayName || userData.username || 'Unknown'}`)
          return {
            success: true,
            user: this.formatUserData(userData),
            authCookie: response.headers['set-cookie'],
            requires2FA: false
          }
        }

        // Se chegou at√© aqui, vamos ver se h√° pelo menos dados de usu√°rio b√°sicos
        if (response.data.username || response.data.displayName) {
          console.log('‚ö†Ô∏è VRChat returned user data without ID, proceeding anyway')
          return {
            success: true,
            user: this.formatUserData(response.data),
            authCookie: response.headers['set-cookie'],
            requires2FA: false
          }
        }
      }

      console.error('‚ùå VRChat API returned unexpected data structure:', response.data)
      throw new Error(`Invalid or incomplete response from VRChat API. Status: ${response.status}`)
    } catch (error) {
      console.error('‚ùå VRChat authentication failed:', error.message)
      
      // Rate limiting - com delays maiores
      if (error.response?.status === 429) {
        if (retryCount < maxRetries) {
          const waitTime = this.rateLimitRetryDelay + (retryCount * 10000) // 30s, 40s, 50s
          console.log(`‚è≥ Rate limited. Aguardando ${Math.round(waitTime/1000)}s antes de retry (tentativa ${retryCount + 1}/${maxRetries + 1})`)
          
          // Verifica se na primeira tentativa foi detectado 2FA antes do rate limit
          let was2FADetected = detected2FA
          
          // Se n√£o foi detectado antes, verifica na resposta atual
          if (!was2FADetected && error.response?.data) {
            was2FADetected = error.response.data.requiresTwoFactorAuth || 
                            (error.response.data.message && 
                             (error.response.data.message.includes('verifica√ß√£o') ||
                              error.response.data.message.includes('2FA') ||
                              error.response.data.message.includes('emailOtp')))
          }
          
          // Logs para debug
          if (was2FADetected) {
            console.log('üîê 2FA detection preserved through rate limit retry')
          }
          
          await new Promise(resolve => setTimeout(resolve, waitTime))
          return this.authenticateUser(username, password, twoFactorAuth, retryCount + 1, was2FADetected)
        } else {
          // M√°ximo de retries atingido
          return {
            success: false,
            error: 'Muitas tentativas falharam devido a rate limiting. Aguarde alguns minutos antes de tentar novamente.',
            rateLimited: true
          }
        }
      }
      
      if (error.response?.status === 401) {
        // Verifica se √© erro de 2FA necess√°rio
        const errorData = error.response.data
        if (errorData?.error?.message?.includes('2FA') || 
            errorData?.message?.includes('2FA') ||
            errorData?.error?.message?.includes('emailOtp') ||
            errorData?.error?.message?.includes('totp') ||
            errorData?.requiresTwoFactorAuth) {
          return {
            success: false,
            requires2FA: true,
            twoFAType: errorData?.requiresTwoFactorAuth,
            error: 'C√≥digo de verifica√ß√£o necess√°rio'
          }
        }
        
        return {
          success: false,
          requires2FA: false,
          error: 'Credenciais inv√°lidas'
        }
      }

      if (error.response?.status === 429) {
        // Se 2FA foi detectado antes do rate limiting, mant√©m a flag
        if (detected2FA) {
          console.log('üîê Rate limited but 2FA was detected previously')
          return {
            success: false,
            requires2FA: true,
            error: 'C√≥digo de verifica√ß√£o necess√°rio. Aguarde alguns minutos devido ao limite de tentativas.'
          }
        }
        
        return {
          success: false,
          requires2FA: false,
          error: 'Muitas tentativas. Aguarde alguns minutos antes de tentar novamente.'
        }
      }

      return {
        success: false,
        requires2FA: false,
        error: 'Erro na conex√£o com VRChat'
      }
    }
  }

  /**
   * Verifica conex√£o com VRChat usando auth cookie
   * @param {string} authCookie - Cookie de autentica√ß√£o
   * @returns {Promise<Object>} Status da conex√£o
   */
  async verifyConnection(authCookie) {
    try {
      const response = await this.axiosInstance.get('/auth/user', {
        headers: {
          'Cookie': authCookie
        }
      })

      return {
        success: true,
        user: this.formatUserData(response.data)
      }
    } catch (error) {
      console.error('‚ùå VRChat connection verification failed:', error.message)
      return {
        success: false,
        error: 'Conex√£o expirada ou inv√°lida'
      }
    }
  }

  /**
   * Busca mundos favoritos do usu√°rio
   * @param {string} authCookie - Cookie de autentica√ß√£o
   * @returns {Promise<Array>} Lista de mundos favoritos
   */
  async getFavoriteWorlds(authCookie) {
    try {
      const response = await this.axiosInstance.get('/favorites', {
        params: {
          type: 'world'
        },
        headers: {
          'Cookie': authCookie
        }
      })

      return response.data.map(favorite => this.formatWorldData(favorite))
    } catch (error) {
      console.error('‚ùå Failed to fetch favorite worlds:', error.message)
      throw error
    }
  }

  /**
   * Busca avatares favoritos do usu√°rio
   * @param {string} authCookie - Cookie de autentica√ß√£o
   * @returns {Promise<Array>} Lista de avatares favoritos
   */
  async getFavoriteAvatars(authCookie) {
    try {
      const response = await this.axiosInstance.get('/favorites', {
        params: {
          type: 'avatar'
        },
        headers: {
          'Cookie': authCookie
        }
      })

      return response.data.map(favorite => this.formatAvatarData(favorite))
    } catch (error) {
      console.error('‚ùå Failed to fetch favorite avatars:', error.message)
      throw error
    }
  }

  /**
   * Busca perfil do usu√°rio
   * @param {string} userId - ID do usu√°rio VRChat
   * @param {string} authCookie - Cookie de autentica√ß√£o
   * @returns {Promise<Object>} Dados do perfil
   */
  async getUserProfile(userId, authCookie) {
    try {
      const response = await this.axiosInstance.get(`/users/${userId}`, {
        headers: {
          'Cookie': authCookie
        }
      })

      return this.formatUserData(response.data)
    } catch (error) {
      console.error('‚ùå Failed to fetch user profile:', error.message)
      throw error
    }
  }

  /**
   * Salva dados de conex√£o VRChat no banco
   * @param {number} userId - ID do usu√°rio no sistema
   * @param {Object} vrchatData - Dados do VRChat
   * @returns {Promise<Object>} Resultado da opera√ß√£o
   */
  async saveVRChatConnection(userId, vrchatData) {
    try {
      // Verifica se j√° existe uma conex√£o
      const existingConnection = await prisma.vRChatConnection.findUnique({
        where: { userId }
      })

      const connectionData = {
        vrchatUserId: vrchatData.id,
        vrchatUsername: vrchatData.username,
        vrchatDisplayName: vrchatData.displayName,
        vrchatBio: vrchatData.bio,
        vrchatAvatarUrl: vrchatData.currentAvatarImageUrl,
        vrchatProfilePicUrl: vrchatData.profilePicOverride || vrchatData.userIcon,
        vrchatTags: JSON.stringify(vrchatData.tags || []),
        vrchatStatus: vrchatData.status,
        vrchatStatusDescription: vrchatData.statusDescription,
        lastSyncAt: new Date(),
        isActive: true
      }

      if (existingConnection) {
        // Atualiza conex√£o existente
        const updated = await prisma.vRChatConnection.update({
          where: { userId },
          data: connectionData
        })
        
        console.log(`‚úÖ Updated VRChat connection for user ${userId}`)
        return { success: true, connection: updated, isNew: false }
      } else {
        // Cria nova conex√£o
        const created = await prisma.vRChatConnection.create({
          data: {
            userId,
            ...connectionData
          }
        })

        console.log(`‚úÖ Created VRChat connection for user ${userId}`)
        return { success: true, connection: created, isNew: true }
      }
    } catch (error) {
      console.error('‚ùå Failed to save VRChat connection:', error)
      throw error
    }
  }

  /**
   * Busca conex√£o VRChat do usu√°rio
   * @param {number} userId - ID do usu√°rio
   * @returns {Promise<Object|null>} Dados da conex√£o
   */
  async getVRChatConnection(userId) {
    try {
      const connection = await prisma.vRChatConnection.findUnique({
        where: { userId, isActive: true }
      })

      return connection
    } catch (error) {
      console.error('‚ùå Failed to get VRChat connection:', error)
      throw error
    }
  }

  /**
   * Remove conex√£o VRChat
   * @param {number} userId - ID do usu√°rio
   * @returns {Promise<boolean>} Sucesso da opera√ß√£o
   */
  async removeVRChatConnection(userId) {
    try {
      await prisma.vRChatConnection.updateMany({
        where: { userId },
        data: { isActive: false }
      })

      console.log(`‚úÖ Removed VRChat connection for user ${userId}`)
      return true
    } catch (error) {
      console.error('‚ùå Failed to remove VRChat connection:', error)
      throw error
    }
  }

  /**
   * Formata dados do usu√°rio VRChat
   * @param {Object} userData - Dados brutos do usu√°rio
   * @returns {Object} Dados formatados
   */
  formatUserData(userData) {
    console.log('üîß Formatting user data:', JSON.stringify(userData, null, 2))
    
    // Extrai dados do usu√°rio independente da estrutura
    const user = userData.user || userData.currentUser || userData
    
    const formatted = {
      id: user.id || user.userId || 'temp_' + Date.now(),
      username: user.username || user.displayName || 'unknown_user',
      displayName: user.displayName || user.username || 'Unknown User',
      bio: user.bio || user.bioLinks || '',
      currentAvatarImageUrl: user.currentAvatarImageUrl || user.profilePicOverride || user.userIcon || null,
      userIcon: user.userIcon || null,
      profilePicOverride: user.profilePicOverride || null,
      status: user.status || user.state || 'offline',
      statusDescription: user.statusDescription || '',
      tags: user.tags || [],
      friendKey: user.friendKey || '',
      isFriend: user.isFriend || false,
      dateJoined: user.date_joined || user.dateJoined || null,
      lastActivity: user.last_activity || user.lastActivity || null
    }
    
    console.log('‚úÖ Formatted user data:', JSON.stringify(formatted, null, 2))
    return formatted
  }

  /**
   * Formata dados do mundo VRChat
   * @param {Object} worldData - Dados brutos do mundo
   * @returns {Object} Dados formatados
   */
  formatWorldData(worldData) {
    return {
      id: worldData.favoriteId,
      worldId: worldData.favoriteId,
      name: worldData.name || 'Mundo Desconhecido',
      description: worldData.description,
      imageUrl: worldData.imageUrl,
      thumbnailImageUrl: worldData.thumbnailImageUrl,
      authorId: worldData.authorId,
      authorName: worldData.authorName,
      capacity: worldData.capacity,
      tags: worldData.tags || [],
      createdAt: worldData.created_at,
      updatedAt: worldData.updated_at
    }
  }

  /**
   * Formata dados do avatar VRChat
   * @param {Object} avatarData - Dados brutos do avatar
   * @returns {Object} Dados formatados
   */
  formatAvatarData(avatarData) {
    return {
      id: avatarData.favoriteId,
      avatarId: avatarData.favoriteId,
      name: avatarData.name || 'Avatar Desconhecido',
      description: avatarData.description,
      imageUrl: avatarData.imageUrl,
      thumbnailImageUrl: avatarData.thumbnailImageUrl,
      authorId: avatarData.authorId,
      authorName: avatarData.authorName,
      tags: avatarData.tags || [],
      releaseStatus: avatarData.releaseStatus,
      createdAt: avatarData.created_at,
      updatedAt: avatarData.updated_at
    }
  }

  /**
   * Sincroniza favoritos do VRChat com o sistema
   * @param {number} userId - ID do usu√°rio
   * @param {string} authCookie - Cookie de autentica√ß√£o
   * @returns {Promise<Object>} Resultado da sincroniza√ß√£o
   */
  async syncFavorites(userId, authCookie) {
    try {
      const [worlds, avatars] = await Promise.all([
        this.getFavoriteWorlds(authCookie),
        this.getFavoriteAvatars(authCookie)
      ])

      // Aqui voc√™ pode implementar a l√≥gica para salvar os favoritos
      // no seu sistema, criar assets autom√°ticamente, etc.

      console.log(`‚úÖ Synced ${worlds.length} worlds and ${avatars.length} avatars for user ${userId}`)
      
      return {
        success: true,
        worlds: worlds.length,
        avatars: avatars.length,
        syncedAt: new Date()
      }
    } catch (error) {
      console.error('‚ùå Failed to sync favorites:', error)
      throw error
    }
  }
}

module.exports = new VRChatService()
